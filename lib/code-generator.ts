import type { Node, Edge } from '@xyflow/react';

export const generateCode = (nodes: Node[], edges: Edge[]): string => {
  if (nodes.length === 0) {
    return `// No nodes found in the flow. Add nodes to generate code.`;
  }

  let code = `// Bitcoin Cash Transaction Script\n`;
  code += `// Generated by CashLabs Flow Builder\n\n`;
  code += `import { TestNetWallet, Wallet } from 'mainnet-js';\n\n`;
  code += `// Configuration\n`;
  code += `const NETWORK = 'testnet'; // Change to 'mainnet' for production\n\n`;

  // Get stored wallet from localStorage if available (for the generated script instructions)
  let storedWif = "";
  try {
    if (typeof window !== 'undefined') {
      const savedWallet = localStorage.getItem("bch-wallet");
      if (savedWallet) {
        const parsedWallet = JSON.parse(savedWallet);
        if (parsedWallet && parsedWallet.privateKeyWif) {
          storedWif = parsedWallet.privateKeyWif;
        }
      }
    }
  } catch (error) { }

  const accountNodes = nodes.filter(node => node.type === 'account');
  accountNodes.forEach(node => {
    const wif = (node.data as any).config?.wif || storedWif || "PASTE_YOUR_WIF_HERE";
    code += `// Wallet from node: ${(node.data as any).label}\n`;
    code += `const ${node.id.replace(/-/g, '_')}_wif = "${wif}";\n`;
  });
  code += '\n';

  code += `async function main() {\n`;
  code += `    try {\n`;
  code += `        console.log('Initializing Bitcoin Cash wallet...');\n\n`;

  // Create wallet instances
  accountNodes.forEach(node => {
    code += `        const ${node.id.replace(/-/g, '_')} = NETWORK === 'testnet'\n`;
    code += `            ? await TestNetWallet.fromWIF(${node.id.replace(/-/g, '_')}_wif)\n`;
    code += `            : await Wallet.fromWIF(${node.id.replace(/-/g, '_')}_wif);\n`;
    code += `        console.log('Wallet address:', ${node.id.replace(/-/g, '_')}.cashaddr);\n\n`;
  });

  // Topological sort to process nodes in correct order
  const sortedNodes = topologicalSort(nodes, edges);

  for (const node of sortedNodes) {
    const sourceEdges = edges.filter(edge => edge.target === node.id);
    const sourceNodes = sourceEdges.map(edge => nodes.find(n => n.id === edge.source));
    const nodeData = node.data as any;
    const config = nodeData.config || {};
    const safeId = node.id.replace(/-/g, '_');

    switch (node.type) {
      case "payment": {
        const senderNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!senderNode) continue;
        const receiver = config.receiver || "RECEIVER_BCH_ADDRESS";
        const amount = config.amount || 0;
        code += `        console.log('Sending ${amount} BCH to ${receiver}...');\n`;
        code += `        const txn_${safeId} = await ${senderNode.id.replace(/-/g, '_')}.send([\n`;
        code += `            { cashaddr: "${receiver}", value: ${amount}, unit: 'bch' }\n`;
        code += `        ]);\n`;
        code += `        console.log('Sent! TxID:', txn_${safeId}.txId);\n\n`;
        break;
      }

      case "multiSend": {
        const senderNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!senderNode) continue;
        const recipients = config.recipients || "";
        const recipientList = recipients.split('\n').map((line: string) => {
          const [addr, amt] = line.split(',').map(s => s.trim());
          if (!addr || !amt) return null;
          return `{ cashaddr: "${addr}", value: ${amt}, unit: 'bch' }`;
        }).filter(Boolean);

        code += `        console.log('Sending bulk transaction to ${recipientList.length} recipients...');\n`;
        code += `        const bulk_${safeId} = await ${senderNode.id.replace(/-/g, '_')}.send([\n`;
        code += `            ${recipientList.join(',\n            ')}\n`;
        code += `        ]);\n`;
        code += `        console.log('Bulk sent! TxID:', bulk_${safeId}.txId);\n\n`;
        break;
      }

      case "tokenCreate": {
        const creatorNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!creatorNode) continue;
        const name = config.name || "My Token";
        const symbol = config.symbol || "TKN";
        const amount = config.amount || 1000000;
        const capability = config.capability || "none";
        const commitment = config.commitment || "";

        code += `        console.log('Generating CashToken: ${name} (${symbol})...');\n`;
        code += `        const genesis_${safeId} = await ${creatorNode.id.replace(/-/g, '_')}.tokenGenesis({\n`;
        code += `            cashaddr: ${creatorNode.id.replace(/-/g, '_')}.cashaddr,\n`;
        code += `            amount: ${amount}n,\n`;
        code += `            capability: "${capability}",\n`;
        code += `            commitment: "${commitment}",\n`;
        code += `            value: 1000\n`;
        code += `        });\n`;
        code += `        console.log('Token created! ID:', genesis_${safeId}.tokenId);\n\n`;
        break;
      }

      case "tokenMint": {
        const minterNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!minterNode) continue;
        const tokenId = config.tokenId || "CATEGORY_ID";
        const amount = config.amount || 1000000;
        const receiver = config.receiver || "";

        code += `        console.log('Minting tokens for ${tokenId}...');\n`;
        code += `        const mint_${safeId} = await ${minterNode.id.replace(/-/g, '_')}.tokenMint("${tokenId}", {\n`;
        code += `            cashaddr: "${receiver}" || ${minterNode.id.replace(/-/g, '_')}.cashaddr,\n`;
        code += `            amount: ${amount}n,\n`;
        code += `            value: 1000\n`;
        code += `        });\n`;
        code += `        console.log('Minted! TxID:', mint_${safeId}.txId);\n\n`;
        break;
      }

      case "tokenBurn": {
        const burnerNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!burnerNode) continue;
        const tokenId = config.tokenId || "CATEGORY_ID";
        const amount = config.amount || 1;

        code += `        console.log('Burning tokens for ${tokenId}...');\n`;
        code += `        const burn_${safeId} = await ${burnerNode.id.replace(/-/g, '_')}.tokenBurn({\n`;
        code += `            tokenId: "${tokenId}",\n`;
        code += `            amount: ${amount}n\n`;
        code += `        });\n`;
        code += `        console.log('Burned! TxID:', burn_${safeId}.txId);\n\n`;
        break;
      }

      case "opReturn": {
        const senderNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!senderNode) continue;
        const message = config.message || "Hello BCH!";
        code += `        console.log('Sending OP_RETURN: "${message}"');\n`;
        code += `        const op_${safeId} = await ${senderNode.id.replace(/-/g, '_')}.send([\n`;
        code += `            ["OP_RETURN", "${message}"]\n`;
        code += `        ]);\n`;
        code += `        console.log('OP_RETURN sent! TxID:', op_${safeId}.txId);\n\n`;
        break;
      }

      case "priceFeed": {
        const nodeForContext = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!nodeForContext) continue;
        code += `        const rate_${safeId} = await ${nodeForContext.id.replace(/-/g, '_')}.getUsdRate();\n`;
        code += `        console.log('Current BCH Price: $' + rate_${safeId} + ' USD');\n\n`;
        break;
      }

      case "delay": {
        const seconds = config.seconds || 5;
        code += `        console.log('Waiting for ${seconds} seconds...');\n`;
        code += `        await new Promise(resolve => setTimeout(resolve, ${seconds} * 1000));\n\n`;
        break;
      }

      case "waitForBalance": {
        const accountNode = sourceNodes.find(n => n?.type === 'account') || accountNodes[0];
        if (!accountNode) continue;
        const target = config.targetBalance || 0.001;
        code += `        console.log('Waiting for balance to reach ${target} BCH...');\n`;
        code += `        const bal_${safeId} = await ${accountNode.id.replace(/-/g, '_')}.waitForBalance(${target}, 'bch');\n`;
        code += `        console.log('Target reached! Balance:', bal_${safeId});\n\n`;
        break;
      }
    }
  }

  code += `        console.log('Flow execution successful.');\n`;
  code += `    } catch (error) {\n`;
  code += `        console.error('Error:', error.message);\n`;
  code += `    }\n`;
  code += `}\n\n`;
  code += `main();\n`;

  return code;
};

const topologicalSort = (nodes: Node[], edges: Edge[]): Node[] => {
  const sorted: Node[] = [];
  const inDegree = new Map<string, number>();
  const adj = new Map<string, string[]>();

  for (const node of nodes) {
    inDegree.set(node.id, 0);
    adj.set(node.id, []);
  }

  for (const edge of edges) {
    adj.get(edge.source)?.push(edge.target);
    inDegree.set(edge.target, (inDegree.get(edge.target) || 0) + 1);
  }

  const queue = nodes.filter(node => inDegree.get(node.id) === 0);

  while (queue.length > 0) {
    const u = queue.shift()!;
    sorted.push(u);

    adj.get(u.id)?.forEach(vId => {
      inDegree.set(vId, (inDegree.get(vId) || 0) - 1);
      if (inDegree.get(vId) === 0) {
        const node = nodes.find(n => n.id === vId);
        if (node) queue.push(node);
      }
    });
  }

  return sorted;
};