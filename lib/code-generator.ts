import type { Node, Edge } from '@xyflow/react';

export const generateCode = (nodes: Node[], edges: Edge[]): string => {
  if (nodes.length === 0) {
    return `// No nodes found in the flow. Add nodes to generate code.`;
  }

  let code = `// Bitcoin Cash Transaction Script\n`;
  code += `// Generated by CashLabs Flow Builder\n\n`;
  code += `import { TestNetWallet, Wallet } from 'mainnet-js';\n\n`;
  code += `// Configuration\n`;
  code += `const NETWORK = 'testnet'; // Change to 'mainnet' for production\n\n`;

  // Get stored wallet
  let storedWif = "";
  let storedMnemonic = "";
  try {
    const savedWallet = localStorage.getItem("bch-wallet");
    if (savedWallet) {
      const parsedWallet = JSON.parse(savedWallet);
      if (parsedWallet && parsedWallet.privateKeyWif) {
        storedWif = parsedWallet.privateKeyWif;
        storedMnemonic = parsedWallet.mnemonic || "";
      }
    }
  } catch (error) {
    console.error("Error parsing wallet from localStorage:", error);
  }

  const accountNodes = nodes.filter(node => node.type === 'account');
  accountNodes.forEach(node => {
    const wif = node.data.config.wif || storedWif || "PASTE_YOUR_WIF_HERE";
    code += `// Wallet from node: ${node.data.label}\n`;
    code += `const ${node.id.replace(/-/g, '_')}_wif = "${wif}";\n`;
  });
  code += '\n';

  code += `async function main() {\n`;
  code += `    try {\n`;
  code += `        console.log('Initializing Bitcoin Cash wallet...');\n\n`;

  // Create wallet instances
  accountNodes.forEach(node => {
    code += `        const ${node.id.replace(/-/g, '_')} = NETWORK === 'testnet'\n`;
    code += `            ? await TestNetWallet.fromWIF(${node.id.replace(/-/g, '_')}_wif)\n`;
    code += `            : await Wallet.fromWIF(${node.id.replace(/-/g, '_')}_wif);\n`;
    code += `        console.log('Wallet address:', ${node.id.replace(/-/g, '_')}.cashaddr);\n\n`;
  });

  // Get balance for account nodes
  accountNodes.forEach(node => {
    code += `        const ${node.id.replace(/-/g, '_')}_balance = await ${node.id.replace(/-/g, '_')}.getBalance();\n`;
    code += `        console.log('Balance:', ${node.id.replace(/-/g, '_')}_balance.bch, 'BCH');\n\n`;
  });

  // Topological sort to process nodes in correct order
  const sortedNodes = topologicalSort(nodes, edges);

  for (const node of sortedNodes) {
    const sourceEdges = edges.filter(edge => edge.target === node.id);
    const sourceNodes = sourceEdges.map(edge => nodes.find(n => n.id === edge.source));

    switch (node.type) {
      case "payment": {
        const senderNode = sourceNodes.find(n => n?.type === 'account');
        if (!senderNode) continue;
        const receiver = node.data.config.receiver || "RECEIVER_BCH_ADDRESS";
        const amount = node.data.config.amount || 0;
        code += `        console.log('Creating payment: ${amount} BCH to ${receiver}');\n`;
        code += `        const txn_${node.id.replace(/-/g, '_')} = await ${senderNode.id.replace(/-/g, '_')}.send([\n`;
        code += `            {\n`;
        code += `                cashaddr: "${receiver}",\n`;
        code += `                value: ${amount},\n`;
        code += `                unit: 'bch'\n`;
        code += `            }\n`;
        code += `        ]);\n`;
        code += `        console.log('Transaction sent! TxID:', txn_${node.id.replace(/-/g, '_')}.txId);\n`;
        code += `        console.log('New balance:', txn_${node.id.replace(/-/g, '_')}.balance.bch, 'BCH');\n\n`;
        break;
      }
      case "tokenCreate": {
        const creatorNode = sourceNodes.find(n => n?.type === 'account');
        if (!creatorNode) continue;
        const amount = node.data.config.amount || 1000000n;
        const commitment = node.data.config.commitment || "";
        const capability = node.data.config.capability || "none";
        code += `        console.log('Creating CashToken...');\n`;
        code += `        const genesis_${node.id.replace(/-/g, '_')} = await ${creatorNode.id.replace(/-/g, '_')}.tokenGenesis({\n`;
        code += `            cashaddr: ${creatorNode.id.replace(/-/g, '_')}.cashaddr,\n`;
        code += `            amount: ${amount}n,\n`;
        code += `            commitment: "${commitment}",\n`;
        code += `            capability: "${capability}",\n`;
        code += `            value: 1000\n`;
        code += `        });\n`;
        code += `        console.log('Token created! TokenId:', genesis_${node.id.replace(/-/g, '_')}.tokenIds[0]);\n\n`;
        break;
      }
      case "tokenTransfer": {
        const senderNode = sourceNodes.find(n => n?.type === 'account');
        if (!senderNode) continue;
        const receiver = node.data.config.receiver || "RECEIVER_BCH_ADDRESS";
        const amount = node.data.config.amount || 0;
        const tokenId = node.data.config.tokenId || "TOKEN_ID";
        code += `        console.log('Transferring CashTokens...');\n`;
        code += `        const transfer_${node.id.replace(/-/g, '_')} = await ${senderNode.id.replace(/-/g, '_')}.send([\n`;
        code += `            new TokenSendRequest({\n`;
        code += `                cashaddr: "${receiver}",\n`;
        code += `                amount: ${amount}n,\n`;
        code += `                tokenId: "${tokenId}",\n`;
        code += `                value: 1000\n`;
        code += `            })\n`;
        code += `        ]);\n`;
        code += `        console.log('Tokens transferred! TxID:', transfer_${node.id.replace(/-/g, '_')}.txId);\n\n`;
        break;
      }
      case "opReturn": {
        const senderNode = sourceNodes.find(n => n?.type === 'account');
        if (!senderNode) continue;
        const message = node.data.config.message || "Hello BCH!";
        code += `        console.log('Sending OP_RETURN message...');\n`;
        code += `        const opreturn_${node.id.replace(/-/g, '_')} = await ${senderNode.id.replace(/-/g, '_')}.send([\n`;
        code += `            ["OP_RETURN", "${message}"]\n`;
        code += `        ]);\n`;
        code += `        console.log('OP_RETURN sent! TxID:', opreturn_${node.id.replace(/-/g, '_')}.txId);\n\n`;
        break;
      }
      case "getBalance": {
        const accountNode = sourceNodes.find(n => n?.type === 'account');
        if (!accountNode) continue;
        code += `        const balance_${node.id.replace(/-/g, '_')} = await ${accountNode.id.replace(/-/g, '_')}.getBalance();\n`;
        code += `        console.log('Balance check:', balance_${node.id.replace(/-/g, '_')});\n\n`;
        break;
      }
      case "waitForBalance": {
        const accountNode = sourceNodes.find(n => n?.type === 'account');
        if (!accountNode) continue;
        const targetBalance = node.data.config.targetBalance || 0.001;
        code += `        console.log('Waiting for balance to reach ${targetBalance} BCH...');\n`;
        code += `        const actualBalance_${node.id.replace(/-/g, '_')} = await ${accountNode.id.replace(/-/g, '_')}.waitForBalance(${targetBalance}, 'bch');\n`;
        code += `        console.log('Target balance reached:', actualBalance_${node.id.replace(/-/g, '_')});\n\n`;
        break;
      }
    }
  }

  code += `    } catch (error) {\n`;
  code += `        console.error('Error:', error.message);\n`;
  code += `        throw error;\n`;
  code += `    }\n`;
  code += `}\n\n`;
  code += `main().catch(error => {\n`;
  code += `    console.error('Fatal error:', error);\n`;
  code += `    process.exit(1);\n`;
  code += `});\n`;

  return code;
};

const topologicalSort = (nodes: Node[], edges: Edge[]): Node[] => {
  const sorted: Node[] = [];
  const inDegree = new Map<string, number>();
  const adj = new Map<string, string[]>();

  for (const node of nodes) {
    inDegree.set(node.id, 0);
    adj.set(node.id, []);
  }

  for (const edge of edges) {
    adj.get(edge.source)?.push(edge.target);
    inDegree.set(edge.target, (inDegree.get(edge.target) || 0) + 1);
  }

  const queue = nodes.filter(node => inDegree.get(node.id) === 0);

  while (queue.length > 0) {
    const u = queue.shift()!;
    sorted.push(u);

    adj.get(u.id)?.forEach(vId => {
      inDegree.set(vId, (inDegree.get(vId) || 0) - 1);
      if (inDegree.get(vId) === 0) {
        const node = nodes.find(n => n.id === vId);
        if (node) queue.push(node);
      }
    });
  }

  return sorted;
};